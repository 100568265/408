# 1.算法

**好算法的特质**

- 正确性
- 可读性
- 健壮性
- 时间复杂度低
- 空间复杂度低





## 1.1 时间复杂度

时间开销T(n)和问题规模n的关系。

**计算方法：**

多项相加，只保留最高阶，且系数化为1

多项相乘，都保留

![image-20241224175840999](./assets/image-20241224175840999.png)





## 1.2 空间复杂度



算法原地工作：表示算法所需内存空间为常量

**变量需要一些内存空间的开销：**

```cpp
void test(int n){
  int flag[n][n];
  int other[n];
  int i;
  //...
}
```



**函数递归调用带来的内存开销：**

```cpp
void loveYou(int n){
  int a,b,c;
  //...
  if(n>1){
    loveYou(n-1);
  }
  printf("I love you%d\n",n);
}
```

函数调用栈，最后当n=1时才结束

空间复杂度=递归调用的深度





# 2.线性表

定义：具有相同数据类型的n个数据元素的有限序列。



**线性表的基本操作：**

`InitList(&L)`初始化表。构造一个空的线性表L，分配内存空间。

`DestroyList(&L)`销毁操作。销毁线性表，并释放线性表所占的内存空间。



`ListInsert(&L,i,e)`插入操作。在表中的第i个位置上插入指定元素e。

`ListDelete(&L,i,&e)`删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值。

`LocateItem(L,e)`按值查找操作。在表L中查找具有给定关键字值的元素。

`GetItem(L,i)`按位查找操作。获取表L中第i个位置的元素的值。

其他常用操作：

`Length(L)`求表长。返回线性表L的长度，即L中的元素个数。

`PrintList(L)`输出操作。

`Empty(L)`判空操作。若L为空表，返回true，否则返回false。





## 顺序表

**定义：**用**顺序存储**的方式实现线性表。

顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。



顺序表的实现 -- 静态分配

```cpp
#define MaxSize 10					//定义最大长度
typedef struct{
  ElemType data[MaxSize];		//静态的数组存放数据元素
  int length;								//顺序表的当前长度
}SqList;
```



顺序表的实现 -- 动态分配

```cpp
typedef struct{
  ElemType *data;						//动态的数组存放数据元素
  int length;								//顺序表的当前长度
  int MaxSize;							//顺序表的最大容量
}SeqList;
```

key：动态的申请和释放内存空间

```cpp
#define InitSize 10    //默认的最大长度
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```



















