# 1.算法

**好算法的特质**

- 正确性
- 可读性
- 健壮性
- 时间复杂度低
- 空间复杂度低





## 1.1 时间复杂度

时间开销T(n)和问题规模n的关系。

**计算方法：**

多项相加，只保留最高阶，且系数化为1

多项相乘，都保留

![image-20241224175840999](./assets/image-20241224175840999.png)





## 1.2 空间复杂度



算法原地工作：表示算法所需内存空间为常量

**变量需要一些内存空间的开销：**

```cpp
void test(int n){
  int flag[n][n];
  int other[n];
  int i;
  //...
}
```



**函数递归调用带来的内存开销：**

```cpp
void loveYou(int n){
  int a,b,c;
  //...
  if(n>1){
    loveYou(n-1);
  }
  printf("I love you%d\n",n);
}
```

函数调用栈，最后当n=1时才结束

空间复杂度=递归调用的深度





# 2.线性表

定义：具有相同数据类型的n个数据元素的有限序列。



**线性表的基本操作：**

`InitList(&L)`初始化表。构造一个空的线性表L，分配内存空间。

`DestroyList(&L)`销毁操作。销毁线性表，并释放线性表所占的内存空间。



`ListInsert(&L,i,e)`插入操作。在表中的第i个位置上插入指定元素e。

`ListDelete(&L,i,&e)`删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值。

`LocateItem(L,e)`按值查找操作。在表L中查找具有给定关键字值的元素。

`GetItem(L,i)`按位查找操作。获取表L中第i个位置的元素的值。

其他常用操作：

`Length(L)`求表长。返回线性表L的长度，即L中的元素个数。

`PrintList(L)`输出操作。

`Empty(L)`判空操作。若L为空表，返回true，否则返回false。





## 顺序表

**定义：**用**顺序存储**的方式实现线性表。

顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。



### 定义

顺序表的实现 -- 静态分配

```cpp
#define MaxSize 10					//定义最大长度
typedef struct{
  ElemType data[MaxSize];		//静态的数组存放数据元素
  int length;								//顺序表的当前长度
}SqList;
```



顺序表的实现 -- 动态分配

```cpp
typedef struct{
  ElemType *data;						//动态的数组存放数据元素
  int length;								//顺序表的当前长度
  int MaxSize;							//顺序表的最大容量
}SeqList;
```

key：动态的申请和释放内存空间

```cpp
#define InitSize 10    //默认的最大长度
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```



### 插入

`ListInsert(&L,i,e)`插入操作。在表中的第i个位置上插入指定元素e。

```cpp
//插入操作，pos为位序
bool ListInsert(SqList &L, int pos, int data) {
    if (pos < 1 || pos > L.length+1) return false;
    if (L.length >= MaxSize) return false;

    for(int i = L.length; i >= pos; i--) {  //将第pos元素及之后的元素往后移
        L.data[i] = L.data[i-1];
    }
    L.data[pos-1] = data;
    L.length++;
    return true;
}
```



### 删除

`ListDelete(&L,i,&e)`删除操作。删除表L中的第i个位置的元素，并用e返回删除元素的值。

```cpp
bool ListDelete(SqList &L, int pos, int &data) {
    if (pos < 1 || pos > L.length) return false;
    data = L.data[pos-1];
    for (int i = pos; i < L.length; i++) {
        L.data[i-1] = L.data[i];
    }
    L.length--;
    return true;
}
```





### 查找



**按位查找**

```cpp
ElemType GetElem(SqList L, int i){
  return L.data[i-1];
}
```



**按值查找**

```cpp
// 按值查找
int LocateElem(SqList L, int value){
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == value)
            return value;
    }
    return 0;
}
```







## 链表



### 定义

```cpp
typedef struct LNode{
    int data;              //数据域
    struct LNode *next;    //指针指向下一个节点
}LNode, *LinkList;
```



**初始化一个单链表**

```cpp
//不带头结点
bool InitList(LinkList &L){
  L = nullptr;
  return true;
}

// 带头结点
bool InitList(LinkList &L){
    L = (LNode*)malloc(sizeof(LNode));
    if(L == nullptr) return false;
    L->next = nullptr;
    return true;
}
```



**判断单链表是否为空**

```cpp
// 不带头结点
bool Empty(LinkList L){
  return L==nullptr;
}

//带头结点
bool Empty(LinkList L){
  return L->next == nullptr;
} 
```



### 插入

带头结点的

```cpp
//按位序插入
bool ListInsert(LinkList &L, int pos, int element){
    if(pos < 1) return false;
    LNode *p = L;    //指针p指向当前扫描到的结点
    int j = 0;
    while(p != nullptr && j < pos){
      p = p->next;    //找到第pos个结点的指针
      j++;
    }
    if(p == nullptr) return false;
    LNode *p2 = (LNode*)malloc(sizeof(LNode));
    p2->data = element;
    p2->next = p->next;
    p->next = p2;
    return true;
}
```

如果是不带头结点的链表，还需要在插入完成后更改头指针指向新结点。



指定结点的后插操作

```cpp
bool InsertNextNode(LNode *p, ElemType e){
  if(p==nullptr) return false;
  LNode *s = (LNode*)malloc(sizeof(LNode));
  if(s == nullptr) return false;	//内存分配失败
  s->data = e;
  s->next = p->next;
  p->next = s;
  return true;
}
```



指定结点的前插操作

```cpp
//前插操作 在p结点之前插入e元素
bool InsertPriorNode(LNode *p, int e){
  if(p == nullptr) return false;
  LNode *s = (LNode*)malloc(sizeof(LNode));
  if(s == nullptr) return false;    //内存分配失败

  // 偷天换日，总的来说就是新结点创建在p之后，把p的值给s，然后p去接新值e
  s->next = p->next;
  p->next = s;          //新结点s连接到p之后
  s->data = p->data;    //把p的元素复制给s
  p->data = e;
  return true;
}
```

或者笨一点的方法就是把头结点传过去,然后找到后继结点是p结点的结点。 





### 删除

按位序删除(带头结点)

```cpp
//按位序删除，带头结点
bool ListDelete(LinkList &L, int pos,int &element){
    if(pos < 1) return false;
    LNode *p = L;
    int j = 0;
    while(p->next != nullptr && j < pos - 1){
      p = p->next;
      j++;
    }
    if(p == nullptr) return false;
    if(p->next == nullptr) return false;
    LNode *q = p->next;    //令q指向被删除的结点
    element = q->data;
    p->next = q->next;    //将结点q从链中断开
    free(q);
    return true;
}

//删除指定的结点p
bool DeleteNode(LNode *p){
    if(p == nullptr) return false;

    //因为找不到p结点前面的结点，除非传入头结点，所以，偷天换日
    LNode *q = p->next;            //令q指向p的后继结点
    p->data = p->next->data;       //p后面那个结点的值给p
    p->next = q->next;
    free(q);
    return true;
}
```



**单链表的局限性：**无法逆向检索，有时候不太方便





### 查找

```cpp
//按值查找(找到数据域==e的结点)
LNode* LocateElem(LinkList L, int element){
	LNode *p = L->next;
    while(p != nullptr && p->data != element)
    	p = p->next;
    return p;
}
```





### 单链表的建立

Step 1：初始化一个单链表

Step 2：插入表头/表尾



**尾插法：**

取一个r指针，永远指向表尾结点，每次插入的时候直接将数据插入到表尾就行







